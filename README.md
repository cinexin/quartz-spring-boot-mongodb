# Using Quartz for Scheduling Jobs in Spring Boot using MongoDB as persistence layer
This project is intended as an scaffold / reference for integrating _Quartz_ scheduling framework into SpringBoot.

Additionally, we override the default _JDBC_ system for persisting _Quartz_ internal tables, and we use _MongoDB_ instead.

This project indeed is just a _fork_ of https://github.com/michaelklishin/quartz-mongodb from __Michael S. Klishin__, we just simpifly the code a little bit, and illustrate how to schedule multiple jobs. 

Feel free to use for your personal o professional purposes
  
## Dependencies
You'll need to have the following dependencies in your pom:
```xml
    <dependencies>
        <!-- Your dependencies here, including Spring Boot ones....-->
        <!-- ..... -->
        <!-- ..... -->
        <!-- ..... -->
		<dependency>
			<groupId>com.novemberain</groupId>
			<artifactId>quartz-mongodb</artifactId>
			<version>2.0.0</version>
		</dependency>
		<dependency>
			<groupId>org.quartz-scheduler</groupId>
			<artifactId>quartz</artifactId>
			<version>2.3.2</version>
		</dependency>
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-lang3</artifactId>
			<version>3.5</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-mongodb</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context-support</artifactId>
		</dependency>
        <!-- ..... -->
        <!-- ..... -->
        <!-- ..... -->
    </dependencies>
```
The _quartz-mongodb_ dependency is not available _per se_ in _Maven Central_ standard repo, so you have to add the following source in your _pom.xml_ too:
```xml
	<repositories>
		<repository>
			<id>michaelklishin</id>
			<url>https://dl.bintray.com/michaelklishin/maven/</url>
		</repository>
	</repositories>
``` 
## Config files
There's an additional config file appart from the Spring usual ones named _quartz.properties_
This file contains _Quartz_ specific config:
```properties
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Quartz Job Scheduling

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Use the MongoDB store

org.quartz.jobStore.class=com.quartz.mongo.intro.quartzintro.scheduler.CustomMongoQuartzSchedulerJobStore

# --- # Note that all the mongo db configuration are set in the CustomMongoQuartzSchedulerJobStore.java class ---

# MongoDB URI (optional if 'org.quartz.jobStore.addresses' is set)

#org.quartz.jobStore.mongoUri=mongodb://localhost:27017

# Comma separated list of mongodb hosts/replica set seeds (optional if 'org.quartz.jobStore.mongoUri' is set)

#org.quartz.jobStore.addresses=localhost

# Will be used to create collections like quartz_jobs, quartz_triggers, quartz_calendars, quartz_locks

org.quartz.jobStore.collectionPrefix=quartz_

# Thread count setting is ignored by the MongoDB store but Quartz requires it

org.quartz.threadPool.threadCount=1

# Skip running a web request to determine if there is an updated version of Quartz available for download

org.quartz.scheduler.skipUpdateCheck=true

org.quartz.jobStore.isClustered=true

#The instance ID will be auto generated by Quartz for all nodes running in a cluster.

org.quartz.scheduler.instanceId=AUTO

org.quartz.scheduler.instanceName=quartzMongoInstance
```

The most relevant properties:  
- __org.quartz.jobStore.class__: It's a reference to the class that will manage the connection to _MongoDB_ database
- __quartz.jobStore.collectionPrefix__: It's the prefix of tables (in this case, _Mongo collections_) that is going to be used for _Quartz_ tables

This configuration is loaded in __QuartzConfiguration__ Spring bean:
```java
@Configuration
public class QuartzConfiguration {

	/**
	 * Here we integrate quartz with Spring and let Spring manage initializing
	 * quartz as a spring bean.
	 * 
	 * @return an instance of {@link SchedulerFactoryBean} which will be managed
	 *         by spring.
	 */
	@Bean
	public SchedulerFactoryBean schedulerFactoryBean() {
		SchedulerFactoryBean scheduler = new SchedulerFactoryBean();
		scheduler.setApplicationContextSchedulerContextKey("applicationContext");
		scheduler.setConfigLocation(new ClassPathResource("quartz.properties"));
		scheduler.setWaitForJobsToCompleteOnShutdown(true);
		return scheduler;
	}

}
```  

And the __CustomMongoQuartzSchedulerJobStore__ should initiate the connection with database:
```java

public class CustomMongoQuartzSchedulerJobStore extends MongoDBJobStore {

	private static String mongoAddresses;

	private static String userName;

	private static String password;

	private static String dbName;

	private static String host;

	private static String port;

	private static String mongoUri(String user,
								  String pass,
								  String host,
								  String port,
								  String database) {

		return user + ":" + pass + "@" + host + ":" + port + "/?authSource=" + database;
	}

	public CustomMongoQuartzSchedulerJobStore() {
		super();
		host = System.getenv("MONGODB_HOST");
		port = System.getenv("MONGODB_PORT");
		dbName = System.getenv("MONGODB_DATABASE");
		userName = System.getenv("MONGODB_USER");
		password = System.getenv("MONGODB_PASSWORD");
		initializeMongo();
		setMongoUri("mongodb://" + mongoAddresses);
		setUsername(userName);
		setPassword(password);
		setDbName(dbName);
		setMongoOptionEnableSSL(true);
		setMongoOptionSslInvalidHostNameAllowed(true);
	}


	/**
	 * <p>
	 * This method will initialize the mongo instance required by the Quartz scheduler
	 * </p>
	 *
	 */
	private static void initializeMongo() {
		mongoAddresses = mongoUri(userName, password, host, port, dbName);
	}

}
```

## Defining Jobs
The jobs we want to be scheduled so they're executed at certain times need to _extend_ __QuartzJobBean__ class
ie:
```java
@PersistJobDataAfterExecution
@DisallowConcurrentExecution
public class JobA extends QuartzJobBean {

	private static Logger log = LoggerFactory.getLogger(JobA.class);

	private ApplicationContext applicationContext;

	/**
	 * This method is called by Spring since we set the
	 * {@link SchedulerFactoryBean#setApplicationContextSchedulerContextKey(String)}
	 * in {@link QuartzConfiguration}
	 * 
	 * @param applicationContext
	 */
	public void setApplicationContext(ApplicationContext applicationContext) {
		this.applicationContext = applicationContext;
	}

	/**
	 * This is the method that will be executed each time the trigger is fired.
	 */
	@Override
	protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
		log.info("This is the A job, executed by {}", applicationContext.getBean(Environment.class));
	}
}
```

Additionally, is highly recommended jobs to be persisted for _logging_ purposes, and if you're in a microservice architecture, you probably don't want the same job to be executed by many instances of same microservice.

That's the purpose of __@PersistJobDataAfterExecution__ and __@DisallowConcurrentExecution__ annotations 

## Jobs triggering configuration
Jobs need to be configured so they're triggered based on some scheduling, this is done associating the _Job_ classes with _triggers_, as in __JobConfiguration__ class:
```java
@Configuration
public class JobConfiguration {

	@Autowired
	private SchedulerFactoryBean schedulerFactoryBean;

	@PostConstruct
	private void initialize() throws Exception {
		schedulerFactoryBean.getScheduler().addJob(jobADetail(), true, true);
		schedulerFactoryBean.getScheduler().addJob(jobBDetail(), true, true);
		if (
				!schedulerFactoryBean.getScheduler().checkExists(
						new TriggerKey(SchedulerConstants.POLLING_TRIGGER_KEY_A, SchedulerConstants.POLLING_GROUP_A)
				)
				&& !schedulerFactoryBean.getScheduler().checkExists(
						new TriggerKey(SchedulerConstants.POLLING_JOB_KEY_B, SchedulerConstants.POLLING_GROUP_B)
				)
		) {
			schedulerFactoryBean.getScheduler().scheduleJob(jobATrigger());
			schedulerFactoryBean.getScheduler().scheduleJob(jobBTrigger());
		}

	}

	/**
	 * <p>
	 * The job is configured here where we provide the job class to be run on
	 * each invocation. We give the job a name and a value so that we can
	 * provide the trigger to it on our method {@link #jobATrigger()}
	 * </p>
	 * 
	 * @return an instance of {@link JobDetail}
	 */
	private static JobDetail jobADetail() {
		JobDetailImpl jobDetail = new JobDetailImpl();
		jobDetail.setKey(new JobKey(SchedulerConstants.POLLING_JOB_KEY_A, SchedulerConstants.POLLING_GROUP_A));
		jobDetail.setJobClass(JobA.class);
		jobDetail.setDurability(true);
		return jobDetail;
	}

	/**
	 * <p>
	 * The job is configured here where we provide the job class to be run on
	 * each invocation. We give the job a name and a value so that we can
	 * provide the trigger to it on our method {@link #jobATrigger()}
	 * </p>
	 *
	 * @return an instance of {@link JobDetail}
	 */
	private static JobDetail jobBDetail() {
		JobDetailImpl jobDetail = new JobDetailImpl();
		jobDetail.setKey(new JobKey(SchedulerConstants.POLLING_JOB_KEY_A, SchedulerConstants.POLLING_GROUP_B));
		jobDetail.setJobClass(JobB.class);
		jobDetail.setDurability(true);
		return jobDetail;
	}
	/**
	 * <p>
	 * This method will define the frequency with which we will be running the
	 * scheduled job which in this instance is every minute three seconds after
	 * the start up.
	 * </p>
	 * 
	 * @return an instance of {@link Trigger}
	 */
	private static Trigger jobATrigger() {
		return newTrigger().forJob(jobADetail())
				.withIdentity(SchedulerConstants.POLLING_TRIGGER_KEY_A, SchedulerConstants.POLLING_GROUP_A)
				.withPriority(50).withSchedule(SimpleScheduleBuilder.repeatMinutelyForever())
				.startAt(Date.from(LocalDateTime.now().plusSeconds(3).atZone(ZoneId.systemDefault()).toInstant()))
				.build();
	}

	/**
	 * <p>
	 * This method will define the frequency with which we will be running the
	 * scheduled job which in this instance is every minute three seconds after
	 * the start up.
	 * </p>
	 *
	 * @return an instance of {@link Trigger}
	 */
	private static Trigger jobBTrigger() {
		return newTrigger().forJob(jobBDetail())
				.withIdentity(SchedulerConstants.POLLING_TRIGGER_KEY_B, SchedulerConstants.POLLING_GROUP_B)
				.withPriority(50).withSchedule(SimpleScheduleBuilder.repeatSecondlyForever())
				.startAt(Date.from(LocalDateTime.now().plusSeconds(3).atZone(ZoneId.systemDefault()).toInstant()))
				.build();
	}
}
``` 

## Running the demo
